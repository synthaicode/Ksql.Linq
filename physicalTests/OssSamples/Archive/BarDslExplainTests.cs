using Ksql.Linq;using Ksql.Linq.Configuration;using Ksql.Linq.Core.Abstractions;using Ksql.Linq.Core.Attributes;using Ksql.Linq.Core.Modeling;using Ksql.Linq.Query.Dsl;using Microsoft.Extensions.Logging;using Xunit;using Confluent.Kafka;using Confluent.Kafka.Admin;using System.Net.Http;using System.Text;using System.Text.Json;using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using System.Threading;namespace Ksql.Linq.Tests.Integration;#nullable enable/// <summary>/// OnModelCreating → ToQuery → Materialize(SQL) → Verify の流れに統一したDSLテスト。/// </summary>public class BarDslExplainTests{    // 監視のON/OFFを環境変数で切替（PHYS_DIAG=1で有効）    private static bool MonitorEnabled => Environment.GetEnvironmentVariable("PHYS_DIAG") == "1";    [KsqlTopic("deduprates")]    public class Rate    {        [KsqlKey(1)] public string Broker { get; set; } = string.Empty;        [KsqlKey(2)] public string Symbol { get; set; } = string.Empty;        [KsqlTimestamp]        public DateTime Timestamp { get; set; }        public double Bid { get; set; }    }    public class Bar    {        [KsqlKey(1)] public string Broker { get; set; } = string.Empty;        [KsqlKey(2)] public string Symbol { get; set; } = string.Empty;        [KsqlKey(3)] public DateTime BucketStart { get; set; }        public double Open { get; set; }        public double High { get; set; }        public double Low { get; set; }        public double KsqlTimeFrameClose { get; set; }    }    private sealed class TestContext : KsqlContext    {        private static readonly ILoggerFactory _loggerFactory = LoggerFactory.Create(b =>        {            b.AddConsole();            b.SetMinimumLevel(LogLevel.Debug);            b.AddFilter("Streamiz.Kafka.Net", LogLevel.Debug);        });        public TestContext() : base(new KsqlDslOptions        {            Common = new CommonSection { BootstrapServers = "127.0.0.1:39092" },            SchemaRegistry = new Ksql.Linq.Core.Configuration.SchemaRegistrySection { Url = "http://127.0.0.1:18081" },            KsqlDbUrl = "http://127.0.0.1:18088",            Topics =            {                ["deduprates"] = new Ksql.Linq.Configuration.Messaging.TopicSection                {                    Producer = new Ksql.Linq.Configuration.Messaging.ProducerSection                    {                        Acks = "All",                        EnableIdempotence = true,                        LingerMs = 0,                        DeliveryTimeoutMs = 30000,                        Retries = 5,                        MaxInFlightRequestsPerConnection = 1,                        BatchSize = 16384,                        RetryBackoffMs = 100,                        CompressionType = "Snappy"                    },                    Creation = new Ksql.Linq.Configuration.Messaging.TopicCreationSection                    {                        NumPartitions = 1,                        ReplicationFactor = 1,                        EnableAutoCreation = false                    }                }            }        }, _loggerFactory)        { }        // 物理テスト: スキーマ登録を有効化        protected override bool SkipSchemaRegistration => false;        // 入力イベントセット（AddAsyncで物理投入）        public EventSet<Rate> Rates { get; set; } = null!;        protected override void OnModelCreating(IModelBuilder modelBuilder)        {            // 入力は属性（[KsqlTopic]/[KsqlTimestamp]）で扱う            // 1m/5mの足は単一DSLで展開（minutes: new[]{1,5}）            modelBuilder.Entity<Bar>()                .ToQuery(q => q.From<Rate>()                    .Tumbling(r => r.Timestamp,new Windows { Minutes = new[] { 1, 5 } })                    .GroupBy(r => new { r.Broker, r.Symbol })                    .Select(g => new Bar                    {                        Broker = g.Key.Broker,                        Symbol = g.Key.Symbol,                        BucketStart = g.WindowStart(),                        Open = g.EarliestByOffset(x => x.Bid),                        High = g.Max(x => x.Bid),                        Low = g.Min(x => x.Bid),                        KsqlTimeFrameClose = g.LatestByOffset(x => x.Bid)                    }));        }    }    [Fact(Skip = "Excluded from physicalTests: duplicated by UT/ToQuery E2E; physical suite focuses on runtime E2E")]    public async Task Tumbling_1m_5m_Live_Ohlc_Materialize_And_Verify()    {        // 事前クリーンアップ（依存順にDROP）        await PhysicalTestEnv.KsqlHelpers.TerminateAndDropBarArtifactsAsync("http://127.0.0.1:18088");        await using var ctx = new TestContext();        // 環境初期化（ksqlDBの起動確認）        await PhysicalTestEnv.KsqlHelpers.WaitForKsqlReadyAsync("http://127.0.0.1:18088", TimeSpan.FromSeconds(180), graceMs: 2000);        // 入力トピックを先に確実に用意（ksqlDBのDDLと競合しない）        using (var admin = new AdminClientBuilder(new AdminClientConfig { BootstrapServers = "127.0.0.1:39092" }).Build())        {            try { await admin.CreateTopicsAsync(new[] { new TopicSpecification { Name = "deduprates", NumPartitions = 1, ReplicationFactor = 1 } }); } catch { }            await PhysicalTestEnv.TopicHelpers.WaitForTopicReady(admin, "deduprates", 1, 1, TimeSpan.FromSeconds(10));        }        // OSSのスキーマ登録・DDL発行を待機（Rateストリーム）        await ctx.WaitForEntityReadyAsync<Rate>(TimeSpan.FromSeconds(60));        // 現在時刻に合わせたバケットで評価（遅延・遡りによるドロップを回避）        // 決定論: 現在依存を排し固定UTC基準（PHYS_BASE_UTCで上書き可）        // 決定論: 固定UTC基準（PHYS_BASE_UTCは使用しない）        DateTime baseUtc = new DateTime(2025, 1, 1, 12, 0, 0, DateTimeKind.Utc);        var t0 = new DateTime(baseUtc.Year, baseUtc.Month, baseUtc.Day, baseUtc.Hour, baseUtc.Minute, 0, DateTimeKind.Utc);        // CSASはOSSが生成（UTでビルダー検証済）。ここでは出力の行出力のみ確認する。        // 行存在確認（テーブルのpullクエリでポーリング）        // push起動はHTTP直叩きで統一（SDK差異を回避）        async Task<int> QueryStreamCountHttpAsync(string sql, int limit, TimeSpan timeout)        {            using var http = new HttpClient { BaseAddress = new Uri("http://127.0.0.1:18088") };            var payload = new            {                sql,                properties = new System.Collections.Generic.Dictionary<string, object>                {                    ["ksql.streams.auto.offset.reset"] = "earliest"                }            };            var json = JsonSerializer.Serialize(payload);            using var content = new StringContent(json, Encoding.UTF8, "application/json");            using var cts = new CancellationTokenSource(timeout);            using var req = new HttpRequestMessage(HttpMethod.Post, "/query-stream") { Content = content };            using var resp = await http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, cts.Token);            resp.EnsureSuccessStatusCode();            await using var stream = await resp.Content.ReadAsStreamAsync(cts.Token);            using var reader = new System.IO.StreamReader(stream, Encoding.UTF8);            int count = 0;            while (!reader.EndOfStream && !cts.IsCancellationRequested)            {                var line = await reader.ReadLineAsync();                if (line == null) break;                if (line.IndexOf("\"row\"", StringComparison.OrdinalIgnoreCase) >= 0)                {                    count++;                    if (count >= limit) break;                }            }            return count;        }        string QueryFor(string table, int limit = 0, bool emitChanges = false)        {            var select = $"SELECT BucketStart, Open, High, Low, KsqlTimeFrameClose FROM {table} WHERE Broker='B1' AND Symbol='S1'";            if (emitChanges)            {                select += " EMIT CHANGES";            }            if (limit > 0)            {                select += $" LIMIT {limit}";            }            select += ";";            return select;        }        // 集計テーブルの生成をpushで待機（取りこぼし防止のためAddAsync前に起動）        async Task<int> WaitPushAsync(string table, int limit, TimeSpan timeout)            => await QueryStreamCountHttpAsync($"SELECT * FROM {table} WHERE Broker='B1' AND Symbol='S1' EMIT CHANGES LIMIT {limit};", limit, timeout);        async Task<int> WaitPullCountAsync(string table, int min, TimeSpan timeout)        {            var start = DateTime.UtcNow;            var deadline = start + timeout;            var last = 0;            while (DateTime.UtcNow < deadline)            {                try                {                    var rows = await ctx.QueryRowsAsync(QueryFor(table, min), TimeSpan.FromSeconds(30));                    last = rows.Count;                    if (last >= min)                        return last;                }                catch (Exception ex)                {                    Console.WriteLine($"WaitPullCountAsync error for {table}: {ex.Message}");                }                await Task.Delay(1000);            }            return last;        }        // 監視（任意）: EMIT CHANGES でライブ到達を観測（本来の検証とは分離）        Task<int>? wait1mTask = null;        Task<int>? wait5mTask = null;        if (MonitorEnabled)        {            wait1mTask = WaitPushAsync("bar_1m_live", 2, TimeSpan.FromSeconds(180));            wait5mTask = WaitPushAsync("bar_5m_live", 1, TimeSpan.FromSeconds(180));        }        var waitPull1Task = WaitPullCountAsync("bar_1m_live", 2, TimeSpan.FromSeconds(180));        var waitPull5Task = WaitPullCountAsync("bar_5m_live", 1, TimeSpan.FromSeconds(180));                var produceTask = Task.Run(async () =>        {            foreach (var (ts, bid) in new[]            {                (t0.AddSeconds(5), 100d),                (t0.AddSeconds(15), 220d),                (t0.AddSeconds(30), 90d),                (t0.AddSeconds(55), 205d),                (t0.AddMinutes(1).AddSeconds(5), 100d),                (t0.AddMinutes(1).AddSeconds(15), 200d),                (t0.AddMinutes(1).AddSeconds(30), 90d),                (t0.AddMinutes(1).AddSeconds(55), 200d)            })            {                await ctx.Rates.AddAsync(new Rate { Broker = "B1", Symbol = "S1", Timestamp = ts, Bid = bid });                await Task.Delay(5);            }        });        await produceTask;        if (MonitorEnabled)        {            await Task.WhenAll(wait1mTask!, wait5mTask!);        }        // 軽いウォームアップ待機（CTASのメタデータ反映と初回集計安定化）        await Task.Delay(5000);        var c1 = await waitPull1Task;        var c5 = await waitPull5Task;        Assert.Equal(2, c1);        Assert.Equal(1, c5);        // 全行を取得して OHLC の正しさを検証（バケット開始で特定）        static long Ms(DateTime dt) => (long)(dt - DateTime.UnixEpoch).TotalMilliseconds;        var bs00 = Ms(t0);        var bs01 = Ms(t0.AddMinutes(1));        // 診断出力: 直近数行をダンプ        var sample = await ctx.QueryRowsAsync("SELECT BucketStart, Open, High, Low, KsqlTimeFrameClose FROM bar_1m_live WHERE Broker='B1' AND Symbol='S1';", TimeSpan.FromSeconds(30));        int diag = 0;        foreach (var r in sample)        {            try            {                Console.WriteLine($"1m row: bs={r[0]}, o={r[1]}, h={r[2]}, l={r[3]}, c={r[4]}");            }            catch { }            if (++diag >= 5) break;        }        var rows1m = sample;        bool ok1 = false, ok2 = false;        foreach (var r in rows1m)        {            var b = Convert.ToInt64(r[0]!);            var o = Convert.ToDouble(r[1]!);            var h = Convert.ToDouble(r[2]!);            var l = Convert.ToDouble(r[3]!);            var c = Convert.ToDouble(r[4]!);            // まずは値一致で確認（BucketStartは診断で別途照合済み）            if (o == 100 && h == 220 && l == 90 && c == 205) ok1 = true;            if (o == 100 && h == 200 && l == 90 && c == 200) ok2 = true;        }        Assert.True(ok1, "1m OHLC for 00:00 mismatch");        Assert.True(ok2, "1m OHLC for 00:01 mismatch");        // 1m: 件数=2と窓集合の一致、各窓のOHLCを即値で検証（decimal）        var actual1m = rows1m.Select(r => Convert.ToInt64(r[0]!)).OrderBy(x => x).ToArray();        Assert.Equal(2, actual1m.Length);        Assert.True(actual1m.SequenceEqual(new[] { bs00, bs01 }), $"1m buckets mismatch: got [{string.Join(",", actual1m)}]");        object?[] RowBy(List<object?[]> rows, long bs) => rows.Single(r => Convert.ToInt64(r[0]!) == bs);        void AssertOhlc(object?[] r, decimal o, decimal h, decimal l, decimal c)        {            Assert.Equal(o, Convert.ToDecimal(r[1]!));            Assert.Equal(h, Convert.ToDecimal(r[2]!));            Assert.Equal(l, Convert.ToDecimal(r[3]!));            Assert.Equal(c, Convert.ToDecimal(r[4]!));        }        AssertOhlc(RowBy(rows1m, bs00), 100m, 220m, 90m, 205m);        AssertOhlc(RowBy(rows1m, bs01), 100m, 200m, 90m, 200m);        var rows5m = await ctx.QueryRowsAsync("SELECT BucketStart, Open, High, Low, KsqlTimeFrameClose FROM bar_5m_live WHERE Broker='B1' AND Symbol='S1';", TimeSpan.FromSeconds(30));        bool ok5 = false;        foreach (var r in rows5m)        {            var b = Convert.ToInt64(r[0]!);            var o = Convert.ToDouble(r[1]!);            var h = Convert.ToDouble(r[2]!);            var l = Convert.ToDouble(r[3]!);            var c = Convert.ToDouble(r[4]!);            if (o == 100 && h == 220 && l == 90 && c == 200) ok5 = true;        }        Assert.True(ok5, "5m OHLC mismatch");        // 5m: 1枠=1行と窓開始の一致、OHLCの即値        Assert.Single(rows5m);        var bucket5mStart = new DateTime(t0.Year, t0.Month, t0.Day, t0.Hour, (t0.Minute / 5) * 5, 0, DateTimeKind.Utc);        var bs05 = (long)(bucket5mStart - DateTime.UnixEpoch).TotalMilliseconds;        Assert.Equal(bs05, Convert.ToInt64(rows5m[0][0]!));        AssertOhlc(rows5m[0], 100m, 220m, 90m, 200m);        // 後片付け        await ctx.ExecuteStatementAsync("TERMINATE ALL;");        await ctx.ExecuteStatementAsync("DROP TABLE IF EXISTS bar_1m_live DELETE TOPIC;");        await ctx.ExecuteStatementAsync("DROP TABLE IF EXISTS bar_5m_live DELETE TOPIC;");        await ctx.ExecuteStatementAsync("DROP TABLE IF EXISTS bar_1m_live DELETE TOPIC;");        await ctx.ExecuteStatementAsync("DROP TABLE IF EXISTS bar_5m_live DELETE TOPIC;");    }}

