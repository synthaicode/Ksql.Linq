using System;
using System.Collections.Generic;
using System.Linq;
using Ksql.Linq.Query.Builders.Common;
using Ksql.Linq.Query.Builders.Functions;
using Ksql.Linq.Query.Dsl;

namespace Ksql.Linq.Query.Hub.Analysis;

/// <summary>
/// Hub-specific selection policy: decides which projection aliases should have
/// their aggregate arguments overridden to hub columns and which aliases should
/// be excluded (computed) from CTAS in hub flows.
/// </summary>
internal static class HubSelectPolicy
{
    public static void BuildOverridesAndExcludes(
        ProjectionMetadata meta,
        out Dictionary<string, HubProjectionOverride> overrides,
        out HashSet<string> excludeAliases,
        System.Collections.Generic.ISet<string>? availableColumns = null)
    {
        overrides = new Dictionary<string, HubProjectionOverride>(StringComparer.OrdinalIgnoreCase);
        excludeAliases = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        static void RegisterExclude(string? alias, HashSet<string> exclude)
        {
            if (string.IsNullOrWhiteSpace(alias))
                return;
            if (string.Equals(alias, "BucketStart", StringComparison.OrdinalIgnoreCase))
                return;
            exclude.Add(alias);
        }

        foreach (var m in meta.Members)
        {
            if (string.IsNullOrWhiteSpace(m.Alias))
                continue;

            if (m.Kind == ProjectionMemberKind.Aggregate)
            {
                var target = ResolveTargetColumn(m);
                if (!string.IsNullOrWhiteSpace(target))
                {
                    overrides[m.Alias] = HubProjectionOverride.ForAggregate(target!, m.AggregateFunctionName);
                    RegisterExclude(m.Alias, excludeAliases);
                }
                continue;
            }

            if (m.Kind == ProjectionMemberKind.Computed
                && ShouldPromoteComputedAlias(m, availableColumns))
            {
                var target = ResolveTargetColumn(m);
                if (!string.IsNullOrWhiteSpace(target))
                {
                    overrides[m.Alias] = HubProjectionOverride.ForAggregate(target!, m.AggregateFunctionName);
                    RegisterExclude(m.Alias, excludeAliases);
                }
            }
        }
    }

    private static bool ShouldPromoteComputedAlias(ProjectionMember member, System.Collections.Generic.ISet<string>? availableColumns)
    {
        if (availableColumns == null || availableColumns.Count == 0)
            return false;

        var sanitizedAlias = member.ResolvedColumnName ?? member.Alias?.ToUpperInvariant();
        if (string.IsNullOrWhiteSpace(sanitizedAlias))
            return false;

        if (!availableColumns.Contains(sanitizedAlias))
            return false;

        return true;
    }

    private static string? ResolveTargetColumn(ProjectionMember member)
    {
        if (!string.IsNullOrWhiteSpace(member.ResolvedColumnName))
            return member.ResolvedColumnName;
        if (!string.IsNullOrWhiteSpace(member.Alias))
            return KsqlNameUtils.Sanitize(member.Alias).ToUpperInvariant();
        return null;
    }

    private static bool ContainsAggregate(System.Linq.Expressions.Expression expression)
    {
        var visitor = new AggregateProbeVisitor();
        visitor.Visit(expression);
        return visitor.FoundAggregate;
    }

    private sealed class AggregateProbeVisitor : System.Linq.Expressions.ExpressionVisitor
    {
        public bool FoundAggregate { get; private set; }

        public override System.Linq.Expressions.Expression? Visit(System.Linq.Expressions.Expression? node)
        {
            if (FoundAggregate || node == null)
                return node;

            if (node is System.Linq.Expressions.MethodCallExpression mc)
            {
                var name = mc.Method.Name;
                if (!string.IsNullOrWhiteSpace(name) && KsqlFunctionRegistry.IsAggregateFunction(name))
                {
                    FoundAggregate = true;
                    return node;
                }
            }

            return base.Visit(node);
        }
    }
}

internal sealed record HubProjectionOverride(string TargetColumn, string? AggregateFunctionName, bool AggregateOnly)
{
    public static HubProjectionOverride ForAggregate(string targetColumn, string? aggregateFunctionName) =>
        new(targetColumn, aggregateFunctionName, AggregateOnly: false);

    public static HubProjectionOverride ForAggregateOnly(string targetColumn, string? aggregateFunctionName) =>
        new(targetColumn, aggregateFunctionName, AggregateOnly: true);
}
